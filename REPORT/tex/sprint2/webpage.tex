\section{Route Designer Web Page}
\label{sec:sprint2-web}

For this sprint, the web page described in \autoref{sec:sprint1-web} should be extended with additional functionality to handle friend lists and requests, as well as server side validation of route data. Additionally, users should have access to an elevation profile of their routes.

\subsection{User Interface Changes}
Only one extra view was planned for this sprint; a friend view, only available to users who are already logged in. This view contains three elements:

\begin{itemize}
	\item{A list of the users current friends.}
	\item{A list of incoming friend requests for the user.}
	\item{A form to request friendship from other users.}
\end{itemize}

The friend list should be a simple list of usernames, with the option to remove friends from the list. The request list will also be a list of usernames, but with options whether to accept or deny the request. In this version, the form will be a text input field and a submit button, requiring the user to match the desired friend's username exactly. While this is certainly not a perfect solution, it serves the purpose of adding some baseline social functionality to the system.

Additionally, a simple elevation profile of the current route should be added to the route planner view.

Apart from the new elements in the interface, the look of the web page should be improved, so that features implemented in the first sprint are more pleasant to use.

\subsection{Database Model Changes}
The database had to be updated to allow for the social aspects. This was accomplished by adding a new table for friends, as can be seen in \autoref{fig:sprint2-db-model}. The \texttt{Friend} table is used to represent both friend requests and established friend relationships, using the \texttt{accepted} column to determine which of the two it is. Apart from this change, the database model is the same as in the previous sprint.

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.5]{img/sprint2db.png}
	\caption{Database Model}
	\label{fig:sprint2-db-model}
\end{figure}

\subsection{Server Implementation}
On the server, two separate parts were implemented: the route validation and the social systems.

\subsubsection{Route Validation}
The route validation consists mostly of writing a server side version of much of the route planner code, employing the web version of the Google Maps \ac{API}, rather than the JavaScript version. This means that given a set waypoints, it is possible for the server to construct the route and calculate its distance, just like the client. Having the distance calculated and stored on the server provides several advantages:
	\begin{itemize}
		\item{A user cannot send forged data to the server, for example create a route that is 5 kilometres, tell the server it is 10 and use that to get matched up against opponents running longer routes.}
		\item{The server can send the length of each route to the mobile application, so presenting the routes to the user does not require recalculating each route on the device.}
		\item{At some point, the matching system will want access to all of the details of a route, so it can calculate a user's progress during a run.}
	\end{itemize}
	Even though the information calculated about a route on the server is considered the correct information, the route designer still presents the information calculated by the client, as this allows for faster information updates during route design.
	
\subsubsection{Social System} 
The social system provides four different actions:
	\begin{itemize}
		\item{Sending a friend request to another user. This requires the other user to not already have an existing friend relationship with the requester (either accepted or pending).}
		\item{Accept and deny incoming friend requests.}
		\item{Remove established friends.}
		\item{Retrieve a list of friends and requests.}
		\end{itemize}
	The main challenge of this was having the server consider entries in the \texttt{Friend} table equal regardless of which user is the \texttt{to} and \texttt{from} user after the request has been accepted, but consider them different while the request is still pending. That is, an accepted friend request makes users mutual friends, while a pending friend request require action from one specific user. This was solved by creating a Django view that retrieves all of a users accepted friends, which can be seen in \autoref{lst:sprint2-get-friends}, while retrieving pending requests is done by filtering requests where the involved user is the \texttt{to} user, and \texttt{accepted} is set to false.


\begin{code}[label={lst:sprint2-get-friends}, caption={Retrieve Friends and Pending Invitations}, language={Python}, style={PythonDoc}]
@login_required
def friendlist(request):
	# Create two lists of Friend instances, inbound and outbound 
	friends_inbound = Friend.objects.filter(accepted=True,
	                                        to_user=request.user)
	friends_outbound = Friend.objects.filter(accepted=True,
	                                         from_user=request.user)
	
	# Create list of all users from the "other end" of inbounds
	friends = [x.from_user for x in friends_inbound]
	# Extend the list with the "other end" of outbound requests
	friends.extend([y.to_user for y in friends_outbound])
	
	return render(request,
	              'friends.html',
	              {'friends': friends,
				   'invites': Friend.objects.filter(
				       to_user=request.user, 
				       accepted=False)})
\end{code}

\subsubsection{Web Client Implementation}
The introduction of elevation profiles was the major point of implementation on the client. Using the Google Maps \ac{API}, getting said elevation profile requires little code. It provides an \texttt{ElevationService} class, which, provided a path in the same format as the one required by the directions service, will return a list of elevation values. These values are then added to a graph using a library called ChartJS~\cite{chartjs}, which is presented to the user. This can be seen in \autoref{fig:sprint2-web-screen}, along with the changes made to the \ac{GUI} of the site.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=\textwidth]{img/webplanner2.png}
	\caption{Webpage}
	\label{fig:sprint2-web-screen}
\end{figure}

\subsection{Testing}
Like the first sprint, unit testing was done with QUnit and coverage metrics was delivered by Blanket. Code coverage after this sprint was reported to be 82\%.

Specific unit tests for the server were not written, instead this was tested by making sure the results for each route was the same as those the client calculated. While not extensive, this was deemed to be enough, seeing as the validation is mostly the same calculations that already happen on the web client.
